最短路径和最小生成树 四个算法，抽象出来的步骤都是：

**a.准备工作：**
1.以某点为起点
2.定义记录数组（最小树的lowcost + adjvex， 最短路径的 final + D + P）

**b.函数体：**

1.数组循环，对每个顶点初始化(根据起点）
2.主循环，逐个求取距离本顶点最近的顶点(min 和 k的更新 , 判断条件，逐个循环  )
3.确定 k 和 min 之后的数据更新 （最短路径数组 / 最小树数组），标记该顶点到集合中，以后不再遍历。 



---



####  **最小生成树**

1. ==Kruskal==

   **以边为起点，逐步找最小权值的邻边。**

   - 令最小生成树的初始状态只有n个顶点而无边的非连通图。

   - 初始时，每个顶点都自成一个连通分量。这些分量不断选择代价最小的边，彼此连接形成更大的分量。

     (如果彼此在一个分量里，则舍去此边，选择下一个代价更小的边)

   - 直到所有顶点在同一连通分量上。

   > 注意：以边为对象需要提前把所有边的权值排列出来。
   >
   > 这时需要特殊结构：**边集数组**
   >
   > ```cpp
   > typedef struct{
   > 	int begin; //起点
   > 	int end; //终点
   > 	int weight; //权值
   > }Edge;//遍历前按权值升序排序
   > ```
   >
   > **构建时要考虑是否会形成环路。**
   >
   > 判断的关键函数 `find:`
   >
   > ```cpp
   > int Find(int parent[],int f)
   > {
   > 	while(parent[f]) f = parent[f];
   > 	return f;
   > }
   > ```

   **两个数组：**

   - `Edge edges[e]` ：如上 

   - `int parent[n]=m` ：将此边的结尾顶点放入下标为起点的parent中。

     > 初始值为0。赋值以后意味着该定点已经在生成树集合中，且通过判断，没有环路。

   **过程：**

   1.初始化parent数组

   2.通过 find 数组，判断当前最短 edge 的 `begin` 和 `end` 没有环路（其结尾顶点不是同一顶点）

   > 判断为真，收入最小生成树集合，并输出。

   **复杂度**：O(elog~e~)

   > 此算法的`Find`函数由边数 e 决定，时间复杂度为O(log~e~)
   >
   > 外面有一个For循环 e 次，所以`Kruskal` 时间复杂度为O(elog~e~)

2. ==Prim==

   以顶点为起点，逐步找各顶点上最小权值的边

   **两个数组：**

   - `int adjvex[MAXVEX]` ：存当前树的顶点集合可以到达的每个顶点下标

   - `int lowcost[MAXVEX]` : 存当前点到达每个顶点的权值 （0代表已加入最小生成树）

   **过程**：

   1.初始化两个数组

   2.主循环：逐个找最小边

   3.找到后，刷新当前定点，同时更新当前点到达每个定点的距离（若为0则不计入）
   
   **复杂度**：O(n^2^)

#### 最短路径

两个都要借助 P、D数组。

- P：Patharc  记录路径权值
- D：ShortPathTable 记录该路径挨着的顶点

1. ==dijkstra==
   **存在起点终点 ， 每次求得起点 v0 到一个v顶点的最短路径**
   故 P、D为一维：

   **三个数组**：

   - `P[v]  `记录 **起点到 v 的权值 。**
   - `D[v] ` 记录 **最短路径上，v 的前一个顶点。** （可以通过递归遍历输出）
   - `final[V] `：final[v] 为真，表示v0到v 的最短路径已求得

   **过程**：

   1.初始化三个数组

   2.开始主循环，每次求得v0 到一个v顶点的最短路径

   3.更新数组，以k为初始点

   **复杂度**：O(n^2^)

2. ==Floyd==

   P、D为二维：

   二维：没有设置起点，遍历所有点为起点。

   **两个数组：**

   - `Patharc[v1] [v2] = k` : v1到v2要经过的第一个顶点k
   - `ShortPathTable[v1] [v2] = k` : v1到v2 的最短路径

   **过程**：

   1.初始化（所有点到点的初始化）

   2.遍历查找所有以 点 k 为中间点，v为起点，w为终点的最短路径。

   3.输出

   **复杂度**：O(n^3^)



#### 有向无环图

最小树和最短路径使用的邻接矩阵，这次的拓扑排序需要用邻接表。

> 拓扑排序时，需要删除顶点，用**邻接表**会更方便。
>
> 在算法过程中，始终要查找入读为0的顶点，所以在顶点表结点结构中，**增加一个入度域 in**
>
> 后续还要用到**栈**，用来存储 入度为0的顶点，避免每次查找到要去遍历顶点表有没有入度为0的顶点。

```cpp
typedef struct EdgeNode //边表结点
{
	int adjvex; //邻接点，存储该顶点对应下标
	int weight;
	struct EdgeNode *next; //指向下一个邻接点
}EdgeNode;

typedef struct VertexNode
{
	int in; //顶点入度
	int data;//顶点信息
	EdgeNode *firstedge; //边表头指针
}VertexNode,AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes,numEdges; //图中当前顶点数和边数
}graphAdjList,*GraphAdjList;
```



1.AOV(Activity On Vertex Network) ：==拓扑排序==



2.AOE(Activity On Edge Network) ：==关键路径==

找关键路径：如果一个事件，最早开始和最晚开始的时间一样，就是关键路径上的事件。

怎么确定**事件**的**最早开始时间 **etv (弧 earliest time of edges)和**最晚开始时间** ltv？(latest)

推导一遍**活动(**顶点Vertexes) 。

1. **先求活动的最早开始和最晚开始时间 etv 和 ltv 。**

>六点放学十点睡觉，同时做数学语文两科作业：数学一小时，语文两小时。
>
>要全部完成的话：最早六点做(6)，最晚八点做（10 - 2 = 8）
>
>如果做完数学(A)和语文(B) 作业要打游戏(C) ,（A->C,  B->C ）：

- 正向进行一次，所有**活动**里完成最晚的即为下一个**事件**的最早开始时间 etv。

  > 写完数学不能打游戏，因为语文还没完成。
  >
  > 写完语文可以打游戏，因为数学提前一小时完成了。
  >
  > `etv =   Max(etv+length<A,C> ,etv+length<B,C>)`

- 逆向进行一次，所有**活动**里完成最早的即为下一个**事件**的最晚开始时间 ltv。

  > 打游戏之前，减去花费最多时间的(还是语文)，即为最晚开始时间。
  >
  > `ltv =  Min（ltv-length<A,C>,ltv - length<B,C>）`

2. **通过 etv 和 ltv 求 ete 和 lte：**

- `ele = etv`
- `lte  = ltv - length`  

3. **判断 `ete == lte `为真 即关键路径上的弧（事件）**

**注意：**

1、若网中有几条关键路径则需加快同时在几条关键路径上的关键活动。

> 如果工程有多条关键路径，单单提高一条关键路径上的关键活动的速度并不能导致整个工程缩短工期，必须同时提高几条关键路径上的活动速度。

2、如果一个活动处于所有的关键路径上，那么提高这项活动的速度，就能缩短整个工程的完成时间。

3、处于所有的关键路径上的活动完成时间不能缩短太否则会使原来的关键路径变成不是关键路径。这时，必须重新寻找关键路径。

**复杂度**：O(n+e)



